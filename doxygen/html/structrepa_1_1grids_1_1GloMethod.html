<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Librepa: repa::grids::GloMethod Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Librepa
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacerepa.html">repa</a></li><li class="navelem"><b>grids</b></li><li class="navelem"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html">GloMethod</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="structrepa_1_1grids_1_1GloMethod-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">repa::grids::GloMethod Struct Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for repa::grids::GloMethod:</div>
<div class="dyncontent">
<div class="center"><img src="structrepa_1_1grids_1_1GloMethod__inherit__graph.png" border="0" usemap="#repa_1_1grids_1_1GloMethod_inherit__map" alt="Inheritance graph"/></div>
<map name="repa_1_1grids_1_1GloMethod_inherit__map" id="repa_1_1grids_1_1GloMethod_inherit__map">
<area shape="rect" title=" " alt="" coords="228,81,383,108"/>
<area shape="rect" href="structrepa_1_1grids_1_1CartGrid.html" title="Regular Cartesian process grid; equally sized boxes, if divisible." alt="" coords="449,5,589,32"/>
<area shape="rect" href="structrepa_1_1grids_1_1Diffusion.html" title="Diffusively load&#45;balanced grid." alt="" coords="447,56,590,83"/>
<area shape="rect" href="structrepa_1_1grids_1_1Graph.html" title=" " alt="" coords="455,107,582,133"/>
<area shape="rect" href="structrepa_1_1grids_1_1GridBasedGrid.html" title="Implements a grid&#45;based load&#45;balancing scheme." alt="" coords="431,157,607,184"/>
<area shape="rect" href="structrepa_1_1grids_1_1ParallelLCGrid.html" title="Interface for a parallel linked&#45;cell grid implementation." alt="" coords="5,81,180,108"/>
<area shape="rect" href="structrepa_1_1grids_1_1PSDiffusion.html" title="Diffusively load&#45;balanced grid based on Diffusion class." alt="" coords="655,56,816,83"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for repa::grids::GloMethod:</div>
<div class="dyncontent">
<div class="center"><img src="structrepa_1_1grids_1_1GloMethod__coll__graph.png" border="0" usemap="#repa_1_1grids_1_1GloMethod_coll__map" alt="Collaboration graph"/></div>
<map name="repa_1_1grids_1_1GloMethod_coll__map" id="repa_1_1grids_1_1GloMethod_coll__map">
<area shape="rect" title=" " alt="" coords="860,111,1015,137"/>
<area shape="rect" href="structrepa_1_1grids_1_1ParallelLCGrid.html" title="Interface for a parallel linked&#45;cell grid implementation." alt="" coords="576,111,751,137"/>
<area shape="rect" href="structrepa_1_1Vec.html" title="Behaves like a std::array." alt="" coords="271,103,398,129"/>
<area shape="rect" href="structrepa_1_1grids_1_1globox_1_1GlobalBox.html" title=" " alt="" coords="587,31,739,87"/>
<area shape="rect" href="structrepa_1_1VecExpression.html" title=" " alt="" coords="24,95,173,137"/>
<area shape="rect" href="structrepa_1_1util_1_1global__index__storage.html" title="Class for storing local and ghost cell indices and the mappings of global indices to local and ghost ..." alt="" coords="606,162,721,203"/>
<area shape="rect" href="structrepa_1_1Vec.html" title=" " alt="" coords="241,20,428,47"/>
<area shape="rect" href="structrepa_1_1VecExpression.html" title=" " alt="" coords="5,5,192,61"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4f2822af1ce09753777fa5fcffe8170e"><td class="memItemLeft" align="right" valign="top"><a id="a4f2822af1ce09753777fa5fcffe8170e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GloMethod</b> (const boost::mpi::communicator &amp;comm, <a class="el" href="structrepa_1_1Vec.html">Vec3d</a> box_size, double min_cell_size, <a class="el" href="structrepa_1_1ExtraParams.html">ExtraParams</a> ep)</td></tr>
<tr class="separator:a4f2822af1ce09753777fa5fcffe8170e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ef52f52a7bd215cfcc234abc88ee86"><td class="memItemLeft" align="right" valign="top"><a id="a21ef52f52a7bd215cfcc234abc88ee86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>after_construction</b> () override</td></tr>
<tr class="separator:a21ef52f52a7bd215cfcc234abc88ee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f8fd27174e1450ab92e6e8dfcc0c93"><td class="memItemLeft" align="right" valign="top"><a id="a32f8fd27174e1450ab92e6e8dfcc0c93"></a>
<a class="el" href="structrepa_1_1util_1_1span.html">util::const_span</a>&lt; <a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a32f8fd27174e1450ab92e6e8dfcc0c93">neighbor_ranks</a> () const override</td></tr>
<tr class="memdesc:a32f8fd27174e1450ab92e6e8dfcc0c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span/range of ranks of all neighbor processes. <br /></td></tr>
<tr class="separator:a32f8fd27174e1450ab92e6e8dfcc0c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b472eb0ed72783af26da97e20364f"><td class="memItemLeft" align="right" valign="top"><a id="ac32b472eb0ed72783af26da97e20364f"></a>
<a class="el" href="structrepa_1_1Vec.html">Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#ac32b472eb0ed72783af26da97e20364f">cell_size</a> () const override</td></tr>
<tr class="memdesc:ac32b472eb0ed72783af26da97e20364f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cell sizes of Linked Cell grid. <br /></td></tr>
<tr class="separator:ac32b472eb0ed72783af26da97e20364f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704b6a301e0d4fd8e29b8bdbe5225e6d"><td class="memItemLeft" align="right" valign="top"><a id="a704b6a301e0d4fd8e29b8bdbe5225e6d"></a>
<a class="el" href="structrepa_1_1Vec.html">Vec3i</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a704b6a301e0d4fd8e29b8bdbe5225e6d">grid_size</a> () const override</td></tr>
<tr class="memdesc:a704b6a301e0d4fd8e29b8bdbe5225e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of grid cells in total in each direction. <br /></td></tr>
<tr class="separator:a704b6a301e0d4fd8e29b8bdbe5225e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4e671d74ffbf7f9d5d45f5aa0aae74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerepa.html#acbb52719ba0ce65c10b3ddf9611584f7">local_or_ghost_cell_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#aeb4e671d74ffbf7f9d5d45f5aa0aae74">cell_neighbor_index</a> (<a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a> cellidx, <a class="el" href="structrepa_1_1IntegralRange.html">fs_neighidx</a> neigh) override</td></tr>
<tr class="memdesc:aeb4e671d74ffbf7f9d5d45f5aa0aae74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a cell neighboring a given cell (by index).  <a href="structrepa_1_1grids_1_1GloMethod.html#aeb4e671d74ffbf7f9d5d45f5aa0aae74">More...</a><br /></td></tr>
<tr class="separator:aeb4e671d74ffbf7f9d5d45f5aa0aae74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f669d31988e2b6c3a6ee30eb31e5d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrepa_1_1util_1_1span.html">util::const_span</a>&lt; <a class="el" href="structrepa_1_1grids_1_1GhostExchangeDesc.html">GhostExchangeDesc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a2f669d31988e2b6c3a6ee30eb31e5d85">get_boundary_info</a> () override</td></tr>
<tr class="memdesc:a2f669d31988e2b6c3a6ee30eb31e5d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ghost exchange info.  <a href="structrepa_1_1grids_1_1GloMethod.html#a2f669d31988e2b6c3a6ee30eb31e5d85">More...</a><br /></td></tr>
<tr class="separator:a2f669d31988e2b6c3a6ee30eb31e5d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70614e9d6664463fe174c63c09eca232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a70614e9d6664463fe174c63c09eca232">position_to_cell_index</a> (<a class="el" href="structrepa_1_1Vec.html">Vec3d</a> pos) override</td></tr>
<tr class="memdesc:a70614e9d6664463fe174c63c09eca232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of a local cell at position "pos".  <a href="structrepa_1_1grids_1_1GloMethod.html#a70614e9d6664463fe174c63c09eca232">More...</a><br /></td></tr>
<tr class="separator:a70614e9d6664463fe174c63c09eca232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6fbe6134ced610bfa0bbf11628a67d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#afa6fbe6134ced610bfa0bbf11628a67d">position_to_rank</a> (<a class="el" href="structrepa_1_1Vec.html">Vec3d</a> pos) override</td></tr>
<tr class="memdesc:afa6fbe6134ced610bfa0bbf11628a67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rank of the process which is responsible for the cell at position "pos".  <a href="structrepa_1_1grids_1_1GloMethod.html#afa6fbe6134ced610bfa0bbf11628a67d">More...</a><br /></td></tr>
<tr class="separator:afa6fbe6134ced610bfa0bbf11628a67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bb6bd3072e4a875ab143afd1b9b252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#ac6bb6bd3072e4a875ab143afd1b9b252">repartition</a> (CellMetric m, CellCellMetric ccm, Thunk exchange_start_callback) override</td></tr>
<tr class="memdesc:ac6bb6bd3072e4a875ab143afd1b9b252"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Maybe</em> repartitions the grid.  <a href="structrepa_1_1grids_1_1GloMethod.html#ac6bb6bd3072e4a875ab143afd1b9b252">More...</a><br /></td></tr>
<tr class="separator:ac6bb6bd3072e4a875ab143afd1b9b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad77649460fa9f57d3d68ba616e7324"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerepa.html#aadf18d98da41914f70acd3c92197d38d">global_cell_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a7ad77649460fa9f57d3d68ba616e7324">global_hash</a> (<a class="el" href="namespacerepa.html#acbb52719ba0ce65c10b3ddf9611584f7">local_or_ghost_cell_index_type</a> cellidx) override</td></tr>
<tr class="memdesc:a7ad77649460fa9f57d3d68ba616e7324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a globally unique id for a local cell.  <a href="structrepa_1_1grids_1_1GloMethod.html#a7ad77649460fa9f57d3d68ba616e7324">More...</a><br /></td></tr>
<tr class="separator:a7ad77649460fa9f57d3d68ba616e7324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structrepa_1_1grids_1_1ParallelLCGrid')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html">repa::grids::ParallelLCGrid</a></td></tr>
<tr class="memitem:aee8a9b9e1cde3e0788670cbf24c62bcf inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#aee8a9b9e1cde3e0788670cbf24c62bcf">ParallelLCGrid</a> (const boost::mpi::communicator &amp;comm, <a class="el" href="structrepa_1_1Vec.html">Vec3d</a> box_size, double min_cell_size)</td></tr>
<tr class="separator:aee8a9b9e1cde3e0788670cbf24c62bcf inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab342f96fcd6c190815b4781b1666c4d inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top"><a id="aab342f96fcd6c190815b4781b1666c4d"></a>
<a class="el" href="namespacerepa.html#a325ecd32d9c4cd3c6cc9f499ab2b64f4">cell_range</a>&lt; <a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#aab342f96fcd6c190815b4781b1666c4d">local_cells</a> () const</td></tr>
<tr class="memdesc:aab342f96fcd6c190815b4781b1666c4d inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of local cells. <br /></td></tr>
<tr class="separator:aab342f96fcd6c190815b4781b1666c4d inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49dd921d70bd986c48fb542e9ab591b inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top"><a id="ab49dd921d70bd986c48fb542e9ab591b"></a>
<a class="el" href="namespacerepa.html#a325ecd32d9c4cd3c6cc9f499ab2b64f4">cell_range</a>&lt; <a class="el" href="namespacerepa.html#a936cbf82bd83c551d67be119bf5381fd">ghost_cell_index_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#ab49dd921d70bd986c48fb542e9ab591b">ghost_cells</a> () const</td></tr>
<tr class="memdesc:ab49dd921d70bd986c48fb542e9ab591b inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the range of ghost cells. <br /></td></tr>
<tr class="separator:ab49dd921d70bd986c48fb542e9ab591b inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfaf8067cb1cff4232a1adc0662a0cb inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#a9bfaf8067cb1cff4232a1adc0662a0cb">command</a> (std::string s)</td></tr>
<tr class="memdesc:a9bfaf8067cb1cff4232a1adc0662a0cb inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deliver implementation-defined commands to the partitioner.  <a href="structrepa_1_1grids_1_1ParallelLCGrid.html#a9bfaf8067cb1cff4232a1adc0662a0cb">More...</a><br /></td></tr>
<tr class="separator:a9bfaf8067cb1cff4232a1adc0662a0cb inherit pub_methods_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a30a8593ffbd8bd7aa775766e3e0d9e7b"><td class="memItemLeft" align="right" valign="top"><a id="a30a8593ffbd8bd7aa775766e3e0d9e7b"></a>
<a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a30a8593ffbd8bd7aa775766e3e0d9e7b">n_local_cells</a> () const override</td></tr>
<tr class="memdesc:a30a8593ffbd8bd7aa775766e3e0d9e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of local cells. <br /></td></tr>
<tr class="separator:a30a8593ffbd8bd7aa775766e3e0d9e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afbcc306bfd28374d17cff3025d2813"><td class="memItemLeft" align="right" valign="top"><a id="a1afbcc306bfd28374d17cff3025d2813"></a>
<a class="el" href="namespacerepa.html#a936cbf82bd83c551d67be119bf5381fd">ghost_cell_index_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a1afbcc306bfd28374d17cff3025d2813">n_ghost_cells</a> () const override</td></tr>
<tr class="memdesc:a1afbcc306bfd28374d17cff3025d2813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of ghost cells. <br /></td></tr>
<tr class="separator:a1afbcc306bfd28374d17cff3025d2813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f80af3fe58b8e8ed3f2f58a27c5ba1a"><td class="memItemLeft" align="right" valign="top"><a id="a1f80af3fe58b8e8ed3f2f58a27c5ba1a"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>sub_repartition</b> (CellMetric m, CellCellMetric ccm)=0</td></tr>
<tr class="separator:a1f80af3fe58b8e8ed3f2f58a27c5ba1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ebdbecf75e414f01d14a729d22e7d2"><td class="memItemLeft" align="right" valign="top"><a id="a35ebdbecf75e414f01d14a729d22e7d2"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>pre_init</b> (bool firstcall)</td></tr>
<tr class="separator:a35ebdbecf75e414f01d14a729d22e7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a22dcbad3a853b5d13f1e948d0907b"><td class="memItemLeft" align="right" valign="top"><a id="ac5a22dcbad3a853b5d13f1e948d0907b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>post_init</b> (bool firstcall)</td></tr>
<tr class="separator:ac5a22dcbad3a853b5d13f1e948d0907b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdfbd1843fc180fc1831bf1e0f092a6"><td class="memItemLeft" align="right" valign="top"><a id="a9bdfbd1843fc180fc1831bf1e0f092a6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_new_foreign_cell</b> (<a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a> localcell, <a class="el" href="namespacerepa.html#aadf18d98da41914f70acd3c92197d38d">global_cell_index_type</a> foreigncell, <a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a> owner)</td></tr>
<tr class="separator:a9bdfbd1843fc180fc1831bf1e0f092a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232754f96b7e60f0db6f785fb71da82b"><td class="memItemLeft" align="right" valign="top"><a id="a232754f96b7e60f0db6f785fb71da82b"></a>
virtual <a class="el" href="structrepa_1_1util_1_1ioptional.html">util::ioptional</a>&lt; <a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rank_of_cell</b> (<a class="el" href="namespacerepa.html#aadf18d98da41914f70acd3c92197d38d">global_cell_index_type</a> idx) const =0</td></tr>
<tr class="separator:a232754f96b7e60f0db6f785fb71da82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeece7f0f506078f49d1542a4fdf4b44d"><td class="memItemLeft" align="right" valign="top"><a id="aeece7f0f506078f49d1542a4fdf4b44d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> (bool firstcall=false)</td></tr>
<tr class="separator:aeece7f0f506078f49d1542a4fdf4b44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2dd74e10f731f00686fde964221c69dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrepa_1_1grids_1_1GloMethod.html#a2dd74e10f731f00686fde964221c69dd">neighbors</a></td></tr>
<tr class="memdesc:a2dd74e10f731f00686fde964221c69dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">All neighbor ranks (ranks of subdomains neighboring this subdomain) Do not use raw access to this vector in the implementation of <a class="el" href="structrepa_1_1grids_1_1GloMethod.html">GloMethod</a>.  <a href="structrepa_1_1grids_1_1GloMethod.html#a2dd74e10f731f00686fde964221c69dd">More...</a><br /></td></tr>
<tr class="separator:a2dd74e10f731f00686fde964221c69dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78843f91bb875ec60e91e15499ca7c4"><td class="memItemLeft" align="right" valign="top"><a id="ac78843f91bb875ec60e91e15499ca7c4"></a>
std::vector&lt; <a class="el" href="structrepa_1_1grids_1_1GhostExchangeDesc.html">GhostExchangeDesc</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>exchangeVector</b></td></tr>
<tr class="separator:ac78843f91bb875ec60e91e15499ca7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d77bd22bf38014d79ea8bd84168d3bf"><td class="memItemLeft" align="right" valign="top"><a id="a2d77bd22bf38014d79ea8bd84168d3bf"></a>
<a class="el" href="structrepa_1_1grids_1_1globox_1_1GlobalBox.html">globox::GlobalBox</a>&lt; <a class="el" href="namespacerepa.html#aadf18d98da41914f70acd3c92197d38d">global_cell_index_type</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>gbox</b></td></tr>
<tr class="separator:a2d77bd22bf38014d79ea8bd84168d3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4158fd26004b5b42b77f411d6f1404d0"><td class="memItemLeft" align="right" valign="top"><a id="a4158fd26004b5b42b77f411d6f1404d0"></a>
const util::InitialPartitionType&#160;</td><td class="memItemRight" valign="bottom"><b>initial_partitioning</b></td></tr>
<tr class="separator:a4158fd26004b5b42b77f411d6f1404d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec58f2d4a895420e0b44c037893fa42"><td class="memItemLeft" align="right" valign="top"><a id="a9ec58f2d4a895420e0b44c037893fa42"></a>
<a class="el" href="structrepa_1_1util_1_1global__index__storage.html">util::global_index_storage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cell_store</b></td></tr>
<tr class="separator:a9ec58f2d4a895420e0b44c037893fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html">repa::grids::ParallelLCGrid</a></td></tr>
<tr class="memitem:a09af5c9305779a7d62d7130f09a6e09a inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top"><a id="a09af5c9305779a7d62d7130f09a6e09a"></a>
const boost::mpi::communicator&#160;</td><td class="memItemRight" valign="bottom"><b>comm</b></td></tr>
<tr class="separator:a09af5c9305779a7d62d7130f09a6e09a inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117858fc046debd63566f620884fb011 inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top"><a id="a117858fc046debd63566f620884fb011"></a>
const boost::mpi::communicator&#160;</td><td class="memItemRight" valign="bottom"><b>comm_cart</b></td></tr>
<tr class="separator:a117858fc046debd63566f620884fb011 inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb987f6b111b1a7bd410de956b0358a inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top"><a id="a0cb987f6b111b1a7bd410de956b0358a"></a>
const <a class="el" href="structrepa_1_1Vec.html">Vec3d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>box_size</b></td></tr>
<tr class="separator:a0cb987f6b111b1a7bd410de956b0358a inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab921c0960caf063b6b6a9586d30fe4d3 inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memItemLeft" align="right" valign="top"><a id="ab921c0960caf063b6b6a9586d30fe4d3"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>min_cell_size</b></td></tr>
<tr class="separator:ab921c0960caf063b6b6a9586d30fe4d3 inherit pro_attribs_structrepa_1_1grids_1_1ParallelLCGrid"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb4e671d74ffbf7f9d5d45f5aa0aae74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4e671d74ffbf7f9d5d45f5aa0aae74">&#9670;&nbsp;</a></span>cell_neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerepa.html#acbb52719ba0ce65c10b3ddf9611584f7">local_or_ghost_cell_index_type</a> repa::grids::GloMethod::cell_neighbor_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a>&#160;</td>
          <td class="paramname"><em>cellidx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrepa_1_1IntegralRange.html">fs_neighidx</a>&#160;</td>
          <td class="paramname"><em>neigh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a cell neighboring a given cell (by index). </p>
<p>The neighbor can either be a local cell or a ghost cell.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if cellidx is not a valid local cell.</td></tr>
  </table>
  </dd>
</dl>
<p>Neighbor 0 is the cells itself, i.e. "cell_neighbor_index(c, 0) == c" Neighbors 1-13: Half shell neighborhood Neighbors 14-26: Rest of full shell neighborhood</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cellidx</td><td>Base cell </td></tr>
    <tr><td class="paramname">neigh</td><td>Neighbor </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#a045508e0d26e677f310fd8c977af4fa3">repa::grids::ParallelLCGrid</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structrepa_1_1grids_1_1GloMethod_aeb4e671d74ffbf7f9d5d45f5aa0aae74_cgraph.png" border="0" usemap="#structrepa_1_1grids_1_1GloMethod_aeb4e671d74ffbf7f9d5d45f5aa0aae74_cgraph" alt=""/></div>
<map name="structrepa_1_1grids_1_1GloMethod_aeb4e671d74ffbf7f9d5d45f5aa0aae74_cgraph" id="structrepa_1_1grids_1_1GloMethod_aeb4e671d74ffbf7f9d5d45f5aa0aae74_cgraph">
<area shape="rect" title="Returns the index of a cell neighboring a given cell (by index)." alt="" coords="5,43,160,84"/>
<area shape="rect" href="structrepa_1_1util_1_1global__index__storage.html#a35cf667db0a067d858af1fc0bc132a76" title="Returns the associated global index of a local cell index." alt="" coords="208,5,419,47"/>
<area shape="rect" href="structrepa_1_1util_1_1global__index__storage.html#a7bf12b5a7f978631da073935709b496b" title="Returns the local or ghost index of a global cell index." alt="" coords="230,71,397,127"/>
</map>
</div>

</div>
</div>
<a id="a2f669d31988e2b6c3a6ee30eb31e5d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f669d31988e2b6c3a6ee30eb31e5d85">&#9670;&nbsp;</a></span>get_boundary_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrepa_1_1util_1_1span.html">util::const_span</a>&lt; <a class="el" href="structrepa_1_1grids_1_1GhostExchangeDesc.html">GhostExchangeDesc</a> &gt; repa::grids::GloMethod::get_boundary_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ghost exchange info. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structrepa_1_1grids_1_1GhostExchangeDesc.html" title="Describes a ghost exchange process.">GhostExchangeDesc</a> </dd></dl>

<p>Implements <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#a58f18af8edcb9af86e3db7d2ad6d22af">repa::grids::ParallelLCGrid</a>.</p>

</div>
</div>
<a id="a7ad77649460fa9f57d3d68ba616e7324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad77649460fa9f57d3d68ba616e7324">&#9670;&nbsp;</a></span>global_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerepa.html#aadf18d98da41914f70acd3c92197d38d">global_cell_index_type</a> repa::grids::GloMethod::global_hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacerepa.html#acbb52719ba0ce65c10b3ddf9611584f7">local_or_ghost_cell_index_type</a>&#160;</td>
          <td class="paramname"><em>cellidx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a globally unique id for a local cell. </p>
<p>This id is uniquely assigned to the global cell corresponding to a local one, i.e. two different processes will return the same global_hash if the (most likely different) local cellidxs correspond to the same global cell. If NDEBUG is set, additionally to the above stated semantics, this function is allowed to return constant 0.</p>
<p>This function is useful for testing purposes only. Use <em>only</em> if NDEBUG is <em>not</em> set. </p>

<p>Implements <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#a0cfd3365a85cf585a9344e1fb1393996">repa::grids::ParallelLCGrid</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structrepa_1_1grids_1_1GloMethod_a7ad77649460fa9f57d3d68ba616e7324_cgraph.png" border="0" usemap="#structrepa_1_1grids_1_1GloMethod_a7ad77649460fa9f57d3d68ba616e7324_cgraph" alt=""/></div>
<map name="structrepa_1_1grids_1_1GloMethod_a7ad77649460fa9f57d3d68ba616e7324_cgraph" id="structrepa_1_1grids_1_1GloMethod_a7ad77649460fa9f57d3d68ba616e7324_cgraph">
<area shape="rect" title="Returns a globally unique id for a local cell." alt="" coords="5,5,160,47"/>
<area shape="rect" href="structrepa_1_1util_1_1global__index__storage.html#a35cf667db0a067d858af1fc0bc132a76" title="Returns the associated global index of a local cell index." alt="" coords="208,5,419,47"/>
</map>
</div>

</div>
</div>
<a id="a70614e9d6664463fe174c63c09eca232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70614e9d6664463fe174c63c09eca232">&#9670;&nbsp;</a></span>position_to_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerepa.html#a796a8a617762ef02b6fcf5db7d7675ba">local_cell_index_type</a> repa::grids::GloMethod::position_to_cell_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrepa_1_1Vec.html">Vec3d</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index of a local cell at position "pos". </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if position is not in the local subdomain. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#a5daabc8921e544b3613600ca32deba37">repa::grids::ParallelLCGrid</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structrepa_1_1grids_1_1GloMethod_a70614e9d6664463fe174c63c09eca232_cgraph.png" border="0" usemap="#structrepa_1_1grids_1_1GloMethod_a70614e9d6664463fe174c63c09eca232_cgraph" alt=""/></div>
<map name="structrepa_1_1grids_1_1GloMethod_a70614e9d6664463fe174c63c09eca232_cgraph" id="structrepa_1_1grids_1_1GloMethod_a70614e9d6664463fe174c63c09eca232_cgraph">
<area shape="rect" title="Returns the index of a local cell at position &quot;pos&quot;." alt="" coords="5,13,164,54"/>
<area shape="rect" href="structrepa_1_1util_1_1global__index__storage.html#abc53be5c8e5584deda6f218bb2e5b71e" title="Returns a local cell index of a global cell index." alt="" coords="212,13,416,54"/>
<area shape="rect" href="structrepa_1_1util_1_1global__index__storage.html#a7bf12b5a7f978631da073935709b496b" title="Returns the local or ghost index of a global cell index." alt="" coords="464,5,631,61"/>
</map>
</div>

</div>
</div>
<a id="afa6fbe6134ced610bfa0bbf11628a67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6fbe6134ced610bfa0bbf11628a67d">&#9670;&nbsp;</a></span>position_to_rank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a> repa::grids::GloMethod::position_to_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrepa_1_1Vec.html">Vec3d</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the rank of the process which is responsible for the cell at position "pos". </p>
<p>Before the first call to <a class="el" href="structrepa_1_1grids_1_1GloMethod.html#ac6bb6bd3072e4a875ab143afd1b9b252" title="Maybe repartitions the grid.">repartition()</a> is guaranteed to work for the whole domain! After the first <a class="el" href="structrepa_1_1grids_1_1GloMethod.html#ac6bb6bd3072e4a875ab143afd1b9b252" title="Maybe repartitions the grid.">repartition()</a> might only work for the process itself and its neighbors or its ghost layer.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if position cannot be resolved because the specific class supports resolving only its subdomain and ghost layer (see above). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#a16721963defda907a3b04c8bccc66436">repa::grids::ParallelLCGrid</a>.</p>

</div>
</div>
<a id="ac6bb6bd3072e4a875ab143afd1b9b252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bb6bd3072e4a875ab143afd1b9b252">&#9670;&nbsp;</a></span>repartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool repa::grids::GloMethod::repartition </td>
          <td>(</td>
          <td class="paramtype">CellMetric&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CellCellMetric&#160;</td>
          <td class="paramname"><em>ccm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Thunk&#160;</td>
          <td class="paramname"><em>exchange_start_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><em>Maybe</em> repartitions the grid. </p>
<p>Returns true if grid has been changed (repartitioned). This means all data of this class is invalidated. If false is returned, <em>no</em> data returned since the last call to <a class="el" href="structrepa_1_1grids_1_1GloMethod.html#ac6bb6bd3072e4a875ab143afd1b9b252" title="Maybe repartitions the grid.">repartition()</a> is invalidated.</p>
<p>The data invalidation includes cell indices. These silently get a new meaning (underlying global cell index).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exchange_start_callback</td><td>is a function with no arguments which starts the data migration. This function is only called if the return value is "true". Also, it is called as soon as "position_to_rank" can safely be called. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="structrepa_1_1grids_1_1ParallelLCGrid.html#aabab09295f9bed8d530b23889abe6562">repa::grids::ParallelLCGrid</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2dd74e10f731f00686fde964221c69dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd74e10f731f00686fde964221c69dd">&#9670;&nbsp;</a></span>neighbors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacerepa.html#a75d2e475d3366f2f02cee0f46e4e1f86">rank_type</a>&gt; repa::grids::GloMethod::neighbors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All neighbor ranks (ranks of subdomains neighboring this subdomain) Do not use raw access to this vector in the implementation of <a class="el" href="structrepa_1_1grids_1_1GloMethod.html">GloMethod</a>. </p>
<p>Use n_neighbors() and neighbor_rank(rank_index_type) instead. At least one subclass (<a class="el" href="structrepa_1_1grids_1_1GridBasedGrid.html" title="Implements a grid-based load-balancing scheme.">GridBasedGrid</a>) uses its own implementaion of the aforementioned menthods which is inconsistent to the ones stored in this vector (might be sorted differently <em>and</em> "neighbors" is not available during initialization). </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>repa/grids/<a class="el" href="glomethod_8hpp_source.html">glomethod.hpp</a></li>
<li>repa/grids/glomethod.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
